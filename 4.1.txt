位运算符的应用：

（1）直接交换两个变量的值

例如，若有变量a = 3，b = 4，想要交换它们的值，可以做如下一组操作：

a ^ = b

b ^ = a

a ^ = b

 

首先，a ^ = b:

     a    0000 0011

^   b    0000 0100

a =     0000 0111

 

其次，b ^ = a:

     b    0000 0100

^   a    0000 0111

b =     0000 0011

 

最后，a ^ = b:

     a    0000 0111

^   b    0000 0011

a =     0000 0100

 

这样，a、b两个变量中的值就进行了对调。

（2)快速乘除运算

移位操作可用于整数的快速乘除运算，左移一位等效于乘2，而右移一位等效于除以2。

如：x = 7， 二进制表达为：0000 0111，

x < < 1               0000 1110，相当于： x =2*7=14，

x < < 3               0111 0000，相当于： x=14*2*2*2=112

x < < 2               1100 0000，             x= 192

在作第三次左移时，其中一位为1的位移到外面去了，而左边只能以0补齐，因而便不等于112*2*2=448，而是等于192了。当x按刚才的步骤反向移动回去时，就不能返回到原来的值了，因为左边丢掉的一个1，再也不能找回来了：

x > > 2              0011 0000，          x=48

x > > 3              0000 0110            x=48/8=6

x > > 1              0000 0011            x=6/2=3

（3)将寄存器指定位置为1

PORTA |= (1<<n)  将porta的第n为置为1，其他为不变。比如说，你如果想将第4位置1，就使用：

PORTA | = (1<< 4) 就行了。当然，也可以使用：

PORTA | = (1<< 7) | (1<< 4 ) | (1<< 0) 这样的指令一次将设第8、5和1位置1，但又不影响到其它位的状态。

（4）将寄存器指定位置为0

PORTA &= ~（1<<n )

这条指令将寄存器的任意位清0，而又不影响其它位的现有状态。比如说，你如果想将第4位清0，就使用：

PORTA & = ~ (1<< 4) 就行了。

 

//下面是POJ 3748题，应用了位操作符：

/*
位操作

Description

假设你工作在一个32位的机器上，你需要将某一个外设寄存器的第X位设置成0(最低位为第0位，最高位为第31位)，
将第Y位开始的连续三位设置成110（从高位到低位的顺序），而其他位保持不变。对给定的寄存器值R，及X，Y，
编程计算更改后的寄存器值R。
Input

仅一行，包括R,X,Y，以逗号","分隔，R为16进制表示的32位整数，X,Y在0-31之间且Y>=3，(Y-X)的绝对值>=3，保证两次置位不会重合
Output

更改后的寄存器值R（16进制输出）
Sample Input

12345678,0,3
Sample Output

1234567c
Source

 */

#include <stdio.h>

int main()
{
 int R, X, Y;

 scanf("%x,%d,%d",&R,&X,&Y);

 R &= ~(1<<X);       // 将R的第X位设置为0
 R |= (1<<Y);        // 将R的第Y位设置为1
 Y--;
 R |= (1<<Y);        // 将R的第Y-1位设置为1
 Y--;
 R &= ~(1<<Y);       // 将R的第Y-2位设置为0

 printf("%x/n",R);

 return 0;
}